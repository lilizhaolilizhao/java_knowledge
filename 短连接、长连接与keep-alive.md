##短连接、长连接与keep-alive
**短连接与长连接**

通俗来讲，浏览器和服务器每进行一次通信，就建立一次连接，任务结束就中断连接，即短连接。相反地，假如通信结束（如完成了某个HTML文件的信息获取）后保持连接则为长连接。在HTTP/1.0中，默认使用短连接。从HTTP/1.1起，默认使用长连接，这样做的优点是显而易见的，一个网页的加载可能需要HTML文件和多个CSS或者JS，假如每获取一个静态文件都建立一次连接，那么就太浪费时间了，而在保持连接的情况下，继续GET即可。

对于频繁请求资源的客户来说，较适用长连接。但连接数最好进行限制，防止建立太多连接拖累服务端。一般浏览器对一个网站的连接是有限制的几个，所以网站会将资源部署在多个域名上以实现浏览器同时请求。

短/长连接应当在TCP连接的范畴中来讨论。有人常说HTTP的短连接和长连接如何如何，但是HTTP只是一个应用层协议，又是无状态的，最终实质性的保持连接还是得靠传输层，即TCP。

举个例子，NginX作为代理的一种常见配置方式是在NginX与客户端之间的连接使用长连接，NginX与后端服务器之间的连接使用短连接。

**keep\-alive**

我们使用浏览器的开发者工具查看网络请求和响应信息时经常在HTTP请求头部看到Connection: keep\-alive，一般的浏览器都会带着个头去请求数据，假如有特殊需求可以用Connection: close断开。HTTP头部的Connection也不一定就被客户端或服务端老老实实地遵循，毕竟各有各的考虑，尤其是在HTTP/1.0这还只是个实验性的功能，而在HTTP/1.1默认长连接于是没有对长连接做特殊的规定。

长连接也不能无限期地长，服务端有可能在头部放Keep\-Alive，其中timeout等于一个值来规定保持连接的秒数，还可以用max来规定多少次请求后断开。如果没有说明怎么断开，主动发起四次握手也可以实现连接的断开。

现在有一个问题就是HTTP的keep\-alive与TCP的keep\-alive到底是什么关系。其实这是两种不同的机制，可以认为没有什么关系。HTTP在头部的Connection中声明keep\-alive可以告诉对方要长连接不立即断开，但是TCP的keep\-alive则是一种检查对方是否仍旧和自己保持着连接的机制以避免自作多情半开放的连接。假如发出一个探测段，成功收到响应，这证明连接正常保持；假如发出一个探测段一段时间后，一个响应都没收到，对方可能已挂断、机器异常或网络异常；假如对方收到探测段但重置，说明原来的连接已经因为某些原因挂断，目前是因为未进行三次握手新建立连接而被挂断。

**Keep-Alive模式**

我们都知道HTTP是基于TCP的，每一个HTTP请求都需要进行三步握手。如果一个页面对某一个域名有多个请求，就会进行频繁的建立连接和断开连接。所以HTTP 1.0中出现了`Connection: keep-alive`，用于建立长连接，即我们所说的Keep\-Alive模式。下图是普通模式和长连接模式的请求对比：

![](https://images2018.cnblogs.com/blog/163758/201805/163758-20180529183054341-2056056277.png)

> HTTP/1.0中默认使用Connection: close。在HTTP/1.1中已经默认使用Connection: keep\-alive。

通过对比可以看出，Keep\-Alive模式更加高效，因为避免了连接建立和释放的开销。但是，如果一个连接是不会断开的，那么多个请求之间如何进行区分呢？也就是说浏览器是如何知道当前请求已经完成了呢？为了解决这个问题，HTTP对header中又添加了一个`Content-Length`字段。

#### Content\-Length

`Content-Length`表示实体内容的长度。浏览器通过这个字段来判断当前请求的数据是否已经全部接收。
所以，当浏览器请求的是一个静态资源时，即服务器能明确知道返回内容的长度时，可以设置`Content-Length`来控制请求的结束。但当服务器并不知道请求结果的长度时，如一个动态的页面或者数据，`Content-Length`就无法解决上面的问题，这个时候就需要用到`Transfer-Encoding`字段。

#### Transfer\-Encoding

`Transfer-Encoding`是指传输编码，还有一个类似的字段叫做：`Content-Encoding`。两者的区别是`Content-Encoding`用于对实体内容的压缩编码，比如`Content-Encoding: gzip`；`Transfer-Encoding`则改变了报文的格式，比如上面的问题中，当服务端无法知道实体内容的长度时，就可以通过指定`Transfer-Encoding: chunked`来告知浏览器当前的编码是将数据分成一块一块传递的。当然, 还可以指定`Transfer-Encoding: gzip, chunked`表明实体内容不仅是gzip压缩的，还是分块传递的。最后，当浏览器接收到一个长度为0的chunked时， 知道当前请求内容已全部接收。