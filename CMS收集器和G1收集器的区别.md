#知识总结第2弹
##CMS收集器和G1收集器的区别
###区别一： 使用范围不一样
> CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用  
> G1收集器收集范围是老年代和新生代。不需要结合其他收集器使用

###区别二： STW的时间
> CMS收集器以最小的停顿时间为目标的收集器  
> G1收集器可预测垃圾回收的停顿时间（建立可预测的停顿时间模型）

###区别三： 垃圾碎片
> CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片  
> G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片

###区别四： 垃圾回收的过程不一样
CMS收集器  |                    G1收集器 |
---|---|
1. 初始标记    |               1. 初始标记
2. 并发标记    |               2. 并发标记
3. 重新标记    |               3. 最终标记
4. 并发清楚    |               4. 筛选回收

##关于BIO和NIO的理解
###简介
> **BIO**：同步阻塞式IO，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善   
> **NIO**：同步非阻塞式IO，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理    
**NIO与BIO最大的区别就是只需要开启一个线程就可以处理来自多个客户端的IO事件**
> **AIO(NIO.2)**：异步非阻塞式IO，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理  

###各自应用场景
> （1）NIO适合处理连接数目特别多，但是连接比较短（轻操作）的场景，Jetty，Mina，ZooKeeper等都是基于java nio实现。

>（2）BIO方式适用于连接数目比较小且固定的场景，这种方式对服务器资源要求比较高，并发局限于应用中。

##理解zookeeper选举机制
###选举流程简述
> 服务器1启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器1的状态一直属于Looking(选举状态)  
> 服务器2启动，给自己投票，同时与之前启动的服务器1交换结果，由于服务器2的编号大所以服务器2胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是LOOKING  
> 服务器3启动，给自己投票，同时与之前启动的服务器1,2交换信息，由于服务器3的编号最大所以服务器3胜出，此时投票数正好大于半数，所以服务器3成为领导者，服务器1,2成为小弟    
> 服务器4启动，给自己投票，同时与之前启动的服务器1,2,3交换信息，尽管服务器4的编号大，但之前服务器3已经胜出，所以服务器4只能成为小弟    
> 服务器5启动，后面的逻辑同服务器4成为小弟   
